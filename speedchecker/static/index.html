<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="300"> <!-- Refreshes page every 5 minutes -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speedcheck tester</title>
    <style>
        :root {
            --bg-color: #fff;
            --text-color: #333;
            --card-bg: #f5f5f5;
            --border-color: #ddd;
            --primary-color: #0066cc; /* OST Download */
            --secondary-color: #4CAF50; /* SS Download */
            --tertiary-color: #ff9800;  /* OST Upload (Orange) */
            --quaternary-color: #9c27b0; /* SS Upload (Purple) */
            --error-color: #f44336;
            --warning-color: #ff9800; /* For mock data notice */
            --header-bg: #333;
            --header-text: #fff;
            --chart-grid: #eee;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --danger-color: #dc3545; /* Clear button */
            --danger-hover-color: #c82333;
        }

        .dark-mode {
            --bg-color: #121212;
            --text-color: #eee;
            --card-bg: #1e1e1e;
            --border-color: #333;
            --primary-color: #4d8edb;   /* OST Download */
            --secondary-color: #81c784; /* SS Download */
            --tertiary-color: #ffb74d;  /* OST Upload (Light Orange) */
            --quaternary-color: #ba68c8; /* SS Upload (Light Purple) */
            --error-color: #e57373;
            --warning-color: #ffb74d; /* For mock data notice */
            --header-bg: #000;
            --header-text: #fff;
            --chart-grid: #333;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --danger-color: #e57373; /* Clear button */
            --danger-hover-color: #f44336;
        }

        /* Basic Styles */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: var(--bg-color); color: var(--text-color); transition: background-color 0.3s, color 0.3s; }
        header { background-color: var(--header-bg); color: var(--header-text); padding: 1rem; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 4px var(--shadow-color); }
        .logo { font-size: 1.5rem; font-weight: bold; display: flex; align-items: center; gap: 10px; }
        .logo svg { width: 24px; height: 24px; stroke: currentColor; stroke-width: 1.5; flex-shrink: 0; }
        .controls { display: flex; gap: 1rem; align-items: center; }
        .theme-toggle { display: flex; align-items: center; cursor: pointer; }
        .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
        .card { background-color: var(--card-bg); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; box-shadow: 0 2px 8px var(--shadow-color); border: 1px solid var(--border-color); }
        h2 { margin-top: 0; color: var(--primary-color); border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }

        /* Test Section */
        .test-options { display: flex; gap: 1rem; margin-bottom: 1.5rem; }
        button { background-color: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-weight: bold; transition: background-color 0.3s; }
        button:hover:not(:disabled) { opacity: 0.9; }
        button:disabled { background-color: var(--border-color); cursor: not-allowed; color: var(--text-color); opacity: 0.6; }
        button.secondary { background-color: var(--secondary-color); }
        button.danger { background-color: var(--danger-color); }
        button.danger:hover:not(:disabled) { background-color: var(--danger-hover-color); opacity: 1; }
        .status { margin: 1rem 0; font-style: italic; min-height: 1.2em; }
        .results { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .result-item { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; display: flex; flex-direction: column; align-items: center; }
        .result-value { font-size: 2.5rem; font-weight: bold; color: var(--primary-color); margin: 0.5rem 0; }
        .result-label { font-size: 0.9rem; color: var(--text-color); opacity: 0.8; }
        .result-unit { font-size: 1rem; color: var(--text-color); opacity: 0.6; }

        /* History Section */
        .history-title { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 1rem; }
        .filter-controls { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
        .filter-controls label { font-weight: bold; font-size: 0.9em; margin-left: 5px; }
        .filter-controls label:first-child { margin-left: 0; }
        .filter-controls input[type="date"],
        .filter-controls input[type="text"],
        .filter-controls select {
            padding: 5px 8px; border: 1px solid var(--border-color); border-radius: 4px; background-color: var(--bg-color); color: var(--text-color); font-size: 0.9em;
        }
        .filter-controls select { max-width: 200px; }
        .filter-controls button { padding: 6px 12px; font-size: 0.9em; }
        .export-clear-controls { margin-left: auto; display: flex; gap: 0.5rem; align-items: center; }
        .export-btn { margin-left: 0; background-color: var(--secondary-color); }

        /* Table Styles */
        table {
             width: 100%; /* Ensure table tries to use full container width */
             border-collapse: collapse;
             margin-top: 1rem;
             table-layout: fixed; /* Use fixed layout algorithm */
             word-wrap: break-word;
         }
        /* === UPDATED Colgroup widths for better space distribution === */
        /* Fixed widths for narrow, predictable columns */
        col.col-provider { width: 90px; } /* Slightly more space for label */
        col.col-ping { width: 80px; }
        col.col-jitter { width: 80px; }
        /* Slightly larger fixed widths for numeric data */
        col.col-dl { width: 110px; }
        col.col-ul { width: 110px; }
        /* Auto width for columns expected to take remaining space */
        col.col-datetime { width: auto; } /* Let Date/Time expand */
        col.col-isp { width: auto; }      /* Let ISP expand */

        th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        th { font-weight: bold; background-color: var(--card-bg); }
        tr:nth-child(even) { background-color: var(--bg-color); }
        tr:hover { background-color: var(--card-bg); }

        /* Pagination Styles */
        #paginationControls { display: flex; justify-content: center; align-items: center; padding: 1rem 0; gap: 1rem; }
        #paginationControls button { padding: 5px 12px; font-size: 0.9em; }
        #pageInfo { font-size: 0.9em; color: var(--text-color); }

        /* Chart Styles */
        .chart-container { height: 300px; margin-top: 1rem; position: relative; }

        /* Utility Styles */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; margin-right: 10px; vertical-align: middle; }
        body:not(.dark-mode) .loading { border: 3px solid rgba(0, 0, 0, 0.2); border-top-color: var(--text-color); }
        .provider-label { display: inline-block; padding: 3px 8px; border-radius: 4px; font-size: 0.75rem; margin-left: 8px; font-weight: normal; vertical-align: middle; }
        .provider-openspeedtest { background-color: #58a6ff; color: white; }
        .provider-speedsmart { background-color: #ff6b6b; color: white; }
        .provider-unknown { background-color: #888; color: white; }
        #noDataMessage { text-align: center; padding: 3rem; color: var(--text-color); opacity: 0.7; }
        .error-message { color: var(--error-color); font-weight: bold; }
        .warning-message { color: var(--warning-color); font-weight: bold; }

    </style>
</head>

<body>
    <header>
        <div class="logo">
             <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M12 8.5V12.5M12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M16 16.5L17.5 17.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M8 16.5L6.5 17.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M19.5 12L21 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M4.5 12L3 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M16 7.5L17.5 6.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> <path d="M8 7.5L6.5 6.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/> </svg>
            Speedcheck tester <span id="connectionMode" class="warning-message" style="font-size: 0.8em; margin-left: 10px; display: none;">(Mock Data Mode)</span>
        </div>
        <div class="controls">
            <div class="theme-toggle" id="themeToggle">
                <svg id="lightIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg>
                <svg id="darkIcon" style="display: none;" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path> </svg>
            </div>
        </div>
    </header>

    <div class="container">
        <!-- Test Card -->
        <div class="card">
            <h2>Run Speedtest</h2>
            <div class="test-options">
                 <button id="openspeedtest" class="secondary">OpenSpeedTest</button>
                 <button id="speedsmart" class="secondary">SpeedSmart</button>
            </div>
            <div id="status" class="status">Initializing...</div>
            <div class="results" id="currentResults" style="display: none;">
                <div class="result-item"> <span class="result-label">Download</span> <div class="result-value" id="downloadValue">0</div> <span class="result-unit">Mbps</span> </div>
                <div class="result-item"> <span class="result-label">Upload</span> <div class="result-value" id="uploadValue">0</div> <span class="result-unit">Mbps</span> </div>
                <div class="result-item"> <span class="result-label">Ping</span> <div class="result-value" id="pingValue">0</div> <span class="result-unit">ms</span> </div>
                <div class="result-item"> <span class="result-label">Jitter</span> <div class="result-value" id="jitterValue">0</div> <span class="result-unit">ms</span> </div>
            </div>
            <div id="serverInfo" style="display: none; margin-top: 1rem;">
                <div><strong>ISP:</strong> <span id="ispValue">-</span></div>
                <div><strong>Server:</strong> <span id="serverValue">-</span></div>
            </div>
        </div>

        <!-- History Card -->
        <div class="card">
            <div class="history-title">
                <h2>Test History</h2>
                <div class="filter-controls">
                     <label for="filterStartDate">From:</label> <input type="date" id="filterStartDate" name="filterStartDate">
                     <label for="filterEndDate">To:</label> <input type="date" id="filterEndDate" name="filterEndDate">
                     <label for="filterProvider">Provider:</label>
                     <select id="filterProvider" name="filterProvider">
                         <option value="all" selected>All</option>
                         <option value="openspeedtest">OpenSpeedTest</option>
                         <option value="speedsmart">SpeedSmart</option>
                     </select>
                     <label for="timezoneSelect">Timezone:</label>
                     <select id="timezoneSelect" name="timezoneSelect"> </select>
                     <button id="clearFiltersBtn" class="secondary">Clear Filters</button>
                </div>
                <div class="export-clear-controls">
                    <button id="exportCsv" class="export-btn" disabled>Export CSV</button>
                    <button id="exportJson" class="export-btn" disabled>Export JSON</button>
                    <button id="clearHistoryBtn" class="danger" disabled>Clear History</button>
                </div>
            </div>
            <div id="historyContainer">
                <div id="noDataMessage">Loading history...</div>
                 <table id="historyTable" style="display: none;">
                    <!-- Colgroup defines column widths -->
                    <colgroup>
                        <col class="col-datetime"> <!-- Auto -->
                        <col class="col-provider"> <!-- Fixed -->
                        <col class="col-dl">       <!-- Fixed -->
                        <col class="col-ul">       <!-- Fixed -->
                        <col class="col-ping">     <!-- Fixed -->
                        <col class="col-jitter">   <!-- Fixed -->
                        <col class="col-isp">      <!-- Auto -->
                    </colgroup>
                    <thead>
                        <tr>
                            <th>Date & Time</th>
                            <th>Provider</th>
                            <th>Download (Mbps)</th>
                            <th>Upload (Mbps)</th>
                            <th>Ping (ms)</th>
                            <th>Jitter (ms)</th>
                            <th>ISP</th>
                        </tr>
                    </thead>
                    <tbody id="historyBody">
                        <!-- Populated by JS -->
                    </tbody>
                </table>
                 <div id="paginationControls">
                    <!-- Populated by JS -->
                 </div>
            </div>
        </div>

        <!-- Chart Cards -->
        <div class="card">
            <h2>Download Speed History</h2>
            <div class="chart-container"> <canvas id="downloadChart"></canvas> </div>
        </div>
        <div class="card">
            <h2>Upload Speed History</h2>
            <div class="chart-container"> <canvas id="uploadChart"></canvas> </div>
        </div>
    </div>

    <!-- JS Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <!-- Main Application Script -->
    <script>
        // --- Mock Data ---
        let mockTestHistorySource = [
            { timestamp: "2023-10-25T10:00:00Z", provider: "openspeedtest", download: 150.5, upload: 45.2, ping: 12.1, jitter: 1.5, isp: "Mock ISP 1", server: "Mock Server A (City X)" },
            { timestamp: "2023-10-25T10:05:00Z", provider: "speedsmart", download: 145.8, upload: 48.9, ping: 15.0, jitter: 2.1, isp: "Mock ISP 1", server: "Mock Server B (City Y)" },
            { timestamp: "2023-10-26T08:30:00Z", provider: "openspeedtest", download: 320.1, upload: 95.6, ping: 8.5, jitter: 0.8, isp: "Mock ISP 2 (Fiber)", server: "Mock Server C (City Z)" },
            { timestamp: "2023-10-26T14:15:00Z", provider: "speedsmart", download: 310.3, upload: 92.1, ping: 10.2, jitter: 1.1, isp: "Mock ISP 2 (Fiber)", server: "Mock Server C (City Z)" },
            { timestamp: "2023-10-27T09:00:00Z", provider: "openspeedtest", download: 95.2, upload: 18.5, ping: 25.3, jitter: 4.5, isp: "Mock ISP 3", server: "Mock Server D (Remote)" },
            { timestamp: "2023-10-28T11:00:00Z", provider: "openspeedtest", download: 180.1, upload: 50.2, ping: 10.5, jitter: 1.1, isp: "Mock ISP 1", server: "Mock Server A (City X)" },
            { timestamp: "2023-10-28T11:05:00Z", provider: "speedsmart", download: 175.8, upload: 52.9, ping: 13.0, jitter: 1.9, isp: "Mock ISP 1", server: "Mock Server B (City Y)" },
            { timestamp: "2023-10-29T09:30:00Z", provider: "openspeedtest", download: 290.1, upload: 85.6, ping: 9.5, jitter: 0.9, isp: "Mock ISP 2 (Fiber)", server: "Mock Server C (City Z)" },
            { timestamp: "2023-10-29T15:15:00Z", provider: "speedsmart", download: 280.3, upload: 82.1, ping: 11.2, jitter: 1.3, isp: "Mock ISP 2 (Fiber)", server: "Mock Server C (City Z)" },
            { timestamp: "2023-10-30T10:00:00Z", provider: "openspeedtest", download: 85.2, upload: 15.5, ping: 28.3, jitter: 5.5, isp: "Mock ISP 3", server: "Mock Server D (Remote)" },
            { timestamp: "2023-10-30T16:00:00Z", provider: "speedsmart", download: 88.0, upload: 16.0, ping: 30.1, jitter: 6.1, isp: "Mock ISP 3", server: "Mock Server D (Remote)" },
        ];

        // --- Global State ---
        let isBackendConnected = false;
        let connectionModeSpan;
        let selectedTimeZone = undefined;
        let timezoneSelectElement;
        let testHistory = [];

        // --- Pagination State ---
        let currentPage = 1;
        const itemsPerPage = 6;

        // --- Curated Timezone List ---
        const commonTimezones = [
            "UTC", "America/New_York", "America/Chicago", "America/Denver", "America/Los_Angeles",
            "Europe/London", "Europe/Paris", "Europe/Moscow", "Asia/Tokyo", "Asia/Shanghai",
            "Asia/Dubai", "Australia/Sydney", "Pacific/Auckland",
        ];

        // --- Scope variables ---
        let themeToggle, lightIcon, darkIcon;
        let openSpeedTestBtn, speedSmartBtn, statusElement, currentResultsElement, serverInfoElement;
        let downloadValue, uploadValue, pingValue, jitterValue, ispValue, serverValue;
        let historyTable, historyBody, noDataMessage, exportCsvBtn, exportJsonBtn, clearHistoryBtn;
        let downloadChart, uploadChart;
        let filterStartDateInput, filterEndDateInput, filterProviderSelect, clearFiltersBtn;
        let paginationControlsContainer;

        // --- Robust Element Assignment Helper ---
        function getElementOrFail(id) {
            const element = document.getElementById(id);
            if (!element) {
                console.error(`Critical Error: Element with ID '${id}' not found! UI may not function correctly.`);
            }
            return element;
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM Content Loaded. Initializing...");
            try {
                assignElements();
                populateTimezoneDropdown();
                setupTheme();
                initCharts();
                setupEventListeners();
                await fetchHistory();
                updateButtonStates();
                console.log("Initialization complete.");
            } catch (error) {
                console.error("Fatal Error during Initialization:", error);
                if (statusElement) { statusElement.innerHTML = `<span class="error-message">Page Initialization Failed. Check console.</span>`; }
                if(openSpeedTestBtn) openSpeedTestBtn.disabled = true;
                if(speedSmartBtn) speedSmartBtn.disabled = true;
                if(clearHistoryBtn) clearHistoryBtn.disabled = true;
                // ... disable other controls if needed
            }
        });

        function assignElements() {
            console.log("Assigning elements...");
            connectionModeSpan = getElementOrFail('connectionMode');
            themeToggle = getElementOrFail('themeToggle'); lightIcon = getElementOrFail('lightIcon'); darkIcon = getElementOrFail('darkIcon');
            openSpeedTestBtn = getElementOrFail('openspeedtest'); speedSmartBtn = getElementOrFail('speedsmart'); statusElement = getElementOrFail('status'); currentResultsElement = getElementOrFail('currentResults'); serverInfoElement = getElementOrFail('serverInfo');
            downloadValue = getElementOrFail('downloadValue'); uploadValue = getElementOrFail('uploadValue'); pingValue = getElementOrFail('pingValue'); jitterValue = getElementOrFail('jitterValue'); ispValue = getElementOrFail('ispValue'); serverValue = getElementOrFail('serverValue');
            historyTable = getElementOrFail('historyTable'); historyBody = getElementOrFail('historyBody'); noDataMessage = getElementOrFail('noDataMessage'); exportCsvBtn = getElementOrFail('exportCsv'); exportJsonBtn = getElementOrFail('exportJson'); clearHistoryBtn = getElementOrFail('clearHistoryBtn');
            filterStartDateInput = getElementOrFail('filterStartDate'); filterEndDateInput = getElementOrFail('filterEndDate');
            filterProviderSelect = getElementOrFail('filterProvider');
            clearFiltersBtn = getElementOrFail('clearFiltersBtn');
            timezoneSelectElement = getElementOrFail('timezoneSelect');
            paginationControlsContainer = getElementOrFail('paginationControls');
            console.log("Element assignment finished.");
        }

        function populateTimezoneDropdown() {
             if (!timezoneSelectElement) { console.warn("Timezone select element not found, skipping population."); return; }
            let detectedLocalTimeZone = "UTC";
            try { detectedLocalTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone; } catch (e) { console.warn("Could not detect local timezone, defaulting to UTC.", e); }
            const timeZoneList = [...new Set([detectedLocalTimeZone, "UTC", ...commonTimezones])].sort();
            timezoneSelectElement.innerHTML = '';
            timeZoneList.forEach(tz => {
                const option = document.createElement('option'); option.value = tz; option.textContent = tz.replace(/_/g, ' '); timezoneSelectElement.appendChild(option);
            });
            try { timezoneSelectElement.value = detectedLocalTimeZone; } catch (e) { timezoneSelectElement.value = timeZoneList.includes("UTC") ? "UTC" : timeZoneList[0]; }
            selectedTimeZone = timezoneSelectElement.value;
        }

        function setupTheme() {
            const savedTheme = localStorage.getItem('theme'); const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)').matches; const useDark = savedTheme === 'dark' || (!savedTheme && prefersDark); document.body.classList.toggle('dark-mode', useDark); if (lightIcon) lightIcon.style.display = useDark ? 'none' : 'block'; if (darkIcon) darkIcon.style.display = useDark ? 'block' : 'none'; if (themeToggle) { themeToggle.addEventListener('click', () => { const isDarkNow = document.body.classList.toggle('dark-mode'); localStorage.setItem('theme', isDarkNow ? 'dark' : 'light'); if(lightIcon) lightIcon.style.display = isDarkNow ? 'none' : 'block'; if(darkIcon) darkIcon.style.display = isDarkNow ? 'block' : 'none'; updateChartsTheme(); }); } else { console.warn("Theme toggle element not found, skipping listener."); }
        }

         function setupEventListeners() {
            console.log("Setting up event listeners...");
            try {
                openSpeedTestBtn?.addEventListener('click', () => runTest('openspeedtest'));
                speedSmartBtn?.addEventListener('click', () => runTest('speedsmart'));
                exportCsvBtn?.addEventListener('click', () => exportHistory('csv'));
                exportJsonBtn?.addEventListener('click', () => exportHistory('json'));
                clearFiltersBtn?.addEventListener('click', () => { console.log("Clear filters clicked."); if (filterStartDateInput) filterStartDateInput.value = ''; if (filterEndDateInput) filterEndDateInput.value = ''; if (filterProviderSelect) filterProviderSelect.value = 'all'; currentPage = 1; updateHistoryTable(); updateCharts(); updateButtonStates(); });
                clearHistoryBtn?.addEventListener('click', clearAllHistory);
                const updateUIOnFilterChange = () => { console.log("Filter changed, updating UI."); currentPage = 1; updateHistoryTable(); updateCharts(); updateButtonStates(); };
                filterStartDateInput?.addEventListener('change', updateUIOnFilterChange);
                filterEndDateInput?.addEventListener('change', updateUIOnFilterChange);
                filterProviderSelect?.addEventListener('change', updateUIOnFilterChange);
                timezoneSelectElement?.addEventListener('change', (event) => { selectedTimeZone = event.target.value; console.log("Timezone selected:", selectedTimeZone); currentPage = 1; updateHistoryTable(); updateCharts(); updateButtonStates(); });
                console.log("Event listeners setup complete.");
            } catch (error) { console.error("Error setting up event listeners:", error); throw error; }
        }

        // --- Data Handling & Backend Interaction ---
        async function fetchHistory() {
            console.log("Fetching history...");
            if(noDataMessage) noDataMessage.textContent = 'Loading history...'; if(noDataMessage) noDataMessage.style.display = 'block'; if(historyTable) historyTable.style.display = 'none'; if(paginationControlsContainer) paginationControlsContainer.innerHTML = ''; if(statusElement) statusElement.textContent = "Connecting to backend...";
            try {
                const response = await fetch('/api/history'); if (!response.ok) { let errorBody = `Status: ${response.status} ${response.statusText}`; try { const textBody = await response.text(); errorBody += ` - Response: ${textBody.substring(0, 200)}`; } catch(e) {} throw new Error(`Backend error: ${errorBody}`); } const data = await response.json(); console.log(`Fetched ${data.length} history records from backend.`); isBackendConnected = true; if(connectionModeSpan) connectionModeSpan.style.display = 'none'; if(statusElement) statusElement.textContent = "Ready."; processAndStoreHistory(data);
            } catch (error) { console.error("Fetch history error:", error); isBackendConnected = false; if(connectionModeSpan) connectionModeSpan.style.display = 'inline'; if(statusElement) statusElement.innerHTML = `<span class="warning-message">Backend connection failed. Using mock data.</span>`; loadMockData();
            } finally { console.log("Fetch history finished. Updating UI."); currentPage = 1; updateHistoryTable(); updateCharts(); }
        }
        function loadMockData() { console.log("Loading mock data..."); try { const historyData = typeof structuredClone === 'function' ? structuredClone(mockTestHistorySource) : JSON.parse(JSON.stringify(mockTestHistorySource)); processAndStoreHistory(historyData); console.log(`Loaded ${testHistory.length} mock history records.`); } catch (error) { console.error("Mock data loading/processing error:", error); testHistory = []; if(noDataMessage) noDataMessage.textContent = 'Failed to load mock data.'; } }
        function processAndStoreHistory(data) { console.log("Processing and storing history data..."); if (!Array.isArray(data)) { console.error("Error: History data received is not an array.", data); testHistory = []; return; } try { const processedData = data.map(t => { const record = { timestamp: t?.timestamp || null, download: parseFloat(t?.download) || 0, upload: parseFloat(t?.upload) || 0, ping: parseFloat(t?.ping) || 0, jitter: parseFloat(t?.jitter) || 0, provider: t?.provider || 'unknown', isp: t?.isp || '-', server: t?.server || '-' }; if (record.timestamp) { try { const d = new Date(record.timestamp); if (isNaN(d.getTime())) { console.warn(`Invalid timestamp format found: ${record.timestamp}.`); } } catch (e) { console.warn(`Error parsing timestamp: ${record.timestamp}.`, e); } } return record; }); processedData.sort((a, b) => { if (!a.timestamp && !b.timestamp) return 0; if (!a.timestamp) return 1; if (!b.timestamp) return -1; try { const dateA = new Date(a.timestamp); const dateB = new Date(b.timestamp); const timeA = !isNaN(dateA.getTime()) ? dateA.getTime() : 0; const timeB = !isNaN(dateB.getTime()) ? dateB.getTime() : 0; return timeB - timeA; } catch (e) { console.warn("Error comparing dates during sort:", a.timestamp, b.timestamp, e); return 0; } }); testHistory = processedData; console.log("History processing complete."); } catch (error) { console.error("Error during history data processing:", error); testHistory = []; } }
        async function runTest(provider) { console.log(`Running test for provider: ${provider}`); if (openSpeedTestBtn) openSpeedTestBtn.disabled = true; if (speedSmartBtn) speedSmartBtn.disabled = true; if (currentResultsElement) currentResultsElement.style.display = 'none'; if (serverInfoElement) serverInfoElement.style.display = 'none'; if (isBackendConnected) { if(statusElement) statusElement.innerHTML = `<span class="loading"></span> Running test via backend (${provider})...`; try { const response = await fetch(`/api/speedtest?provider=${provider}`, { method: 'POST' }); if (!response.ok) { let errorMsg = `Backend error: ${response.status}`; try { const errData = await response.json(); errorMsg += ` - ${errData.error || JSON.stringify(errData)}`; } catch(e) {} throw new Error(errorMsg); } const data = await response.json(); if (data.error) { throw new Error(`Backend test error: ${data.error} ${data.output ? JSON.stringify(data.output):''}`); } console.log("Backend test result:", data); displayResults(data, provider); await fetchHistory(); if(statusElement) statusElement.textContent = 'Test completed.'; } catch (error) { console.error(`Run test error (${provider}):`, error); if(statusElement) statusElement.innerHTML = `<span class="error-message">Failed: ${error.message}</span>`; if (error instanceof TypeError) { console.warn("Connection likely lost. Switching to mock mode."); isBackendConnected = false; if(connectionModeSpan) connectionModeSpan.style.display = 'inline'; } } finally { updateButtonStates(); } } else { if(statusElement) statusElement.innerHTML = `<span class="loading"></span> Running mock test (${provider})...`; setTimeout(() => { try { const now = new Date(); const mockResult = { timestamp: now.toISOString(), provider: provider, download: (Math.random() * 400 + 50), upload: (Math.random() * 80 + 10), ping: (Math.random() * 45 + 5), jitter: (Math.random() * 9 + 1), isp: "Your ISP (Mock)", server: `Mock Server ${String.fromCharCode(65 + Math.floor(Math.random() * 5))} (City ${String.fromCharCode(88 + Math.floor(Math.random() * 3))})` }; testHistory.unshift(mockResult); let displayData = {}; if (provider === 'openspeedtest') { displayData = { 'Download Speed': `${mockResult.download.toFixed(2)} Mbps`, 'Upload Speed': `${mockResult.upload.toFixed(2)} Mbps`, 'Ping': `${mockResult.ping.toFixed(1)} ms`, 'Jitter': `${mockResult.jitter.toFixed(2)} ms`, 'Server Location': mockResult.isp, 'Server Name': mockResult.server }; } else { displayData = { download_speed: mockResult.download, upload_speed: mockResult.upload, ping_speed: mockResult.ping, jitter: mockResult.jitter, isp_name: mockResult.isp, server_name: mockResult.server }; } displayResults(displayData, provider); currentPage = 1; updateHistoryTable(); updateCharts(); if(statusElement) statusElement.textContent = 'Mock test completed.'; } catch (error) { console.error(`Mock run test error (${provider}):`, error); if(statusElement) statusElement.innerHTML = `<span class="error-message">Mock Failed: ${error.message}</span>`; } finally { updateButtonStates(); } }, 1500); } }
        async function clearAllHistory() { if (!isBackendConnected) { alert("Cannot clear history while disconnected."); return; } if (confirm('Are you sure you want to delete ALL test history?')) { if(statusElement) statusElement.innerHTML = `<span class="loading"></span> Clearing history...`; if(clearHistoryBtn) clearHistoryBtn.disabled = true; try { const response = await fetch('/api/history', { method: 'DELETE' }); if (!response.ok) { let errorMsg = `Failed to clear history: ${response.status}`; try { const errData = await response.json(); errorMsg += ` - ${errData.error || JSON.stringify(errData)}`; } catch(e) {} throw new Error(errorMsg); } const result = await response.json(); console.log("Clear history result:", result.message); if(statusElement) statusElement.textContent = "History cleared."; testHistory = []; currentPage = 1; updateHistoryTable(); updateCharts(); } catch (error) { console.error("Clear history error:", error); if(statusElement) statusElement.innerHTML = `<span class="error-message">Error clearing history: ${error.message}</span>`; if (error instanceof TypeError) { isBackendConnected = false; if(connectionModeSpan) connectionModeSpan.style.display = 'inline'; } } finally { updateButtonStates(); } } }
        function updateButtonStates() { console.log("Updating button states..."); const canRunTest = true; const canClear = isBackendConnected; const hasAnyData = testHistory.length > 0; let hasFilteredData = false; try { hasFilteredData = getFilteredHistory().length > 0; } catch (error) { console.error("Error checking filtered data for button states:", error); } if (openSpeedTestBtn) openSpeedTestBtn.disabled = !canRunTest; if (speedSmartBtn) speedSmartBtn.disabled = !canRunTest; if (clearHistoryBtn) clearHistoryBtn.disabled = !canClear || !hasAnyData; if (exportCsvBtn) exportCsvBtn.disabled = !hasFilteredData; if (exportJsonBtn) exportJsonBtn.disabled = !hasFilteredData; }
        function displayResults(data, provider) { console.log("Displaying current test results..."); if (!currentResultsElement || !serverInfoElement || !downloadValue || !uploadValue || !pingValue || !jitterValue || !ispValue || !serverValue ) { console.error("Cannot display results: Elements missing."); return; } try { currentResultsElement.style.display = 'grid'; serverInfoElement.style.display = 'block'; const formatNum = (val, digits = 2) => (parseFloat(val) || 0).toFixed(digits); const formatPing = (val) => (parseFloat(val) || 0).toFixed(1); if (provider === 'openspeedtest') { downloadValue.textContent = formatNum(data['Download Speed']?.split(' ')[0]); uploadValue.textContent = formatNum(data['Upload Speed']?.split(' ')[0]); pingValue.textContent = formatPing(data['Ping']?.split(' ')[0]); jitterValue.textContent = formatNum(data['Jitter']?.split(' ')[0]); ispValue.textContent = data['Server Location'] || '-'; serverValue.textContent = data['Server Name'] || '-'; } else { downloadValue.textContent = formatNum(data.download_speed); uploadValue.textContent = formatNum(data.upload_speed); pingValue.textContent = formatPing(data.ping_speed); jitterValue.textContent = formatNum(data.jitter); ispValue.textContent = data.isp_name || '-'; serverValue.textContent = data.server_name || '-'; } } catch (e) { console.error("Display results parse error:", e, data); if(statusElement) statusElement.innerHTML += `<br/><span class="error-message">Result display error.</span>`; currentResultsElement.style.display = 'none'; serverInfoElement.style.display = 'none'; } }

        // --- Filtering and Display Logic ---
        function getFilteredHistory() { const start = filterStartDateInput?.value; const end = filterEndDateInput?.value; const provider = filterProviderSelect?.value || 'all'; const endDateTime = end ? new Date(end) : null; if (endDateTime) { endDateTime.setHours(23, 59, 59, 999); } if (!Array.isArray(testHistory)) { console.error("Cannot filter: testHistory is not an array."); return []; } return testHistory.filter(t => { if (!t || typeof t !== 'object' || !t.timestamp) return false; let itemDate; try { itemDate = new Date(t.timestamp); if (isNaN(itemDate.getTime())) return false; } catch (e) { console.warn("Error parsing date during filter:", t.timestamp, e); return false; } const dateOk = (!start || itemDate >= new Date(start)) && (!endDateTime || itemDate <= endDateTime); const providerOk = (provider === 'all' || t.provider === provider); return dateOk && providerOk; }); }
        function updateHistoryTable() { console.log(`Updating history table page ${currentPage}...`); if (!historyTable || !historyBody || !noDataMessage || !paginationControlsContainer) { console.error("Cannot update history table: Elements missing."); return; } let filtered = []; try { filtered = getFilteredHistory(); } catch (error) { console.error("Error getting filtered history:", error); noDataMessage.textContent = "Error applying filters."; noDataMessage.style.display = 'block'; historyTable.style.display = 'none'; paginationControlsContainer.innerHTML = ''; return; } const totalFilteredItems = filtered.length; const totalPages = Math.ceil(totalFilteredItems / itemsPerPage) || 1; if (currentPage > totalPages) { currentPage = totalPages; } else if (currentPage < 1) { currentPage = 1; } const startIndex = (currentPage - 1) * itemsPerPage; const endIndex = startIndex + itemsPerPage; const pageData = filtered.slice(startIndex, endIndex); const hasDataOnPage = pageData.length > 0; historyTable.style.display = hasDataOnPage ? 'table' : 'none'; noDataMessage.style.display = hasDataOnPage ? 'none' : 'block'; if (!hasDataOnPage) { noDataMessage.textContent = totalFilteredItems === 0 ? (testHistory.length === 0 ? (isBackendConnected ? 'No tests run yet.' : 'No mock data available.') : 'No results match filters.') : `No results on Page ${currentPage}.`; } historyBody.innerHTML = ''; const currentTZ = selectedTimeZone || Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"; let dateFormatter; try { dateFormatter = new Intl.DateTimeFormat(undefined, { year: 'numeric', month: 'short', day: '2-digit', hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: false, timeZone: currentTZ, timeZoneName: 'short' }); } catch (e) { console.error(`Invalid timezone "${currentTZ}". Falling back to UTC.`, e); dateFormatter = new Intl.DateTimeFormat(undefined, { year: 'numeric', month: 'short', day: '2-digit', hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: false, timeZone: "UTC", timeZoneName: 'short'}); } try { pageData.forEach(t => { const row = historyBody.insertRow(); const providerClass = t.provider || 'unknown'; let provAbbr = 'UNK'; if (providerClass === 'openspeedtest') provAbbr = 'OST'; else if (providerClass === 'speedsmart') provAbbr = 'SS'; let formattedDate = '-'; if (t.timestamp) { try { const dateObj = new Date(t.timestamp); if (!isNaN(dateObj.getTime())) { formattedDate = dateFormatter.format(dateObj); } else { formattedDate = 'Invalid Date'; } } catch (e) { console.warn("Error formatting date in table cell:", t.timestamp, e); formattedDate = 'Formatting Error'; } } const download = (t.download || 0).toFixed(2); const upload = (t.upload || 0).toFixed(2); const ping = parseFloat(t.ping || 0).toFixed(1); const jitter = (t.jitter || 0).toFixed(2); const isp = t.isp || '-'; row.innerHTML = `<td>${formattedDate}</td><td><span class="provider-label provider-${providerClass}">${provAbbr}</span></td><td>${download}</td><td>${upload}</td><td>${ping}</td><td>${jitter}</td><td>${isp}</td>`; }); } catch (error) { console.error("Error populating history table rows:", error); historyBody.innerHTML = `<tr><td colspan="7" class="error-message">Error displaying rows. Check console.</td></tr>`; historyTable.style.display = 'table'; } renderPaginationControls(totalFilteredItems, totalPages); console.log("History table update complete."); }
        function renderPaginationControls(totalItems, totalPages) { console.log(`Rendering pagination: page ${currentPage}/${totalPages}, ${totalItems} items total`); if (!paginationControlsContainer) { console.warn("Pagination container not found."); return; } paginationControlsContainer.innerHTML = ''; if (totalPages <= 1) { console.log("Skipping pagination controls (<= 1 page)."); return; } try { const prevButton = document.createElement('button'); prevButton.textContent = 'Previous'; prevButton.disabled = (currentPage === 1); prevButton.addEventListener('click', () => { console.log("Previous clicked."); if (currentPage > 1) { currentPage--; updateHistoryTable(); updateButtonStates(); } }); paginationControlsContainer.appendChild(prevButton); const pageInfo = document.createElement('span'); pageInfo.id = 'pageInfo'; pageInfo.textContent = totalItems === 0 ? `Page 1 of 1 (0 results)` : `Page ${currentPage} of ${totalPages} (${totalItems} results)`; paginationControlsContainer.appendChild(pageInfo); const nextButton = document.createElement('button'); nextButton.textContent = 'Next'; nextButton.disabled = (currentPage === totalPages); nextButton.addEventListener('click', () => { console.log("Next clicked."); if (currentPage < totalPages) { currentPage++; updateHistoryTable(); updateButtonStates(); } }); paginationControlsContainer.appendChild(nextButton); console.log("Pagination controls rendered."); } catch (error) { console.error("Error rendering pagination controls:", error); paginationControlsContainer.innerHTML = `<span class="error-message">Error creating pagination.</span>`; } }

        // --- Chart Logic ---
        function initCharts() { console.log("Initializing charts..."); try { const dCtx = document.getElementById('downloadChart')?.getContext('2d'); const uCtx = document.getElementById('uploadChart')?.getContext('2d'); if (!dCtx || !uCtx) { console.warn("Chart canvas context not found, skipping chart init."); return; } const colors = getChartColors(); const opts = getBaseChartOptions(colors); if (downloadChart instanceof Chart) downloadChart.destroy(); if (uploadChart instanceof Chart) uploadChart.destroy(); downloadChart = new Chart(dCtx, { type: 'line', data: { datasets: [ { label: 'OpenSpeed Test Down (Mbps)', data: [], borderColor: colors.ostDownload, backgroundColor: colors.ostDownloadAlpha, tension: 0.1, fill: false, pointRadius: 3, spanGaps: false }, { label: 'Speed Smart Test Down (Mbps)', data: [], borderColor: colors.ssDownload, backgroundColor: colors.ssDownloadAlpha, tension: 0.1, fill: false, pointRadius: 3, spanGaps: false } ] }, options: opts }); uploadChart = new Chart(uCtx, { type: 'line', data: { datasets: [ { label: 'OpenSpeed Test Up (Mbps)', data: [], borderColor: colors.ostUpload, backgroundColor: colors.ostUploadAlpha, tension: 0.1, fill: false, pointRadius: 3, spanGaps: false }, { label: 'Speed Smart Test Up (Mbps)', data: [], borderColor: colors.ssUpload, backgroundColor: colors.ssUploadAlpha, tension: 0.1, fill: false, pointRadius: 3, spanGaps: false } ] }, options: opts }); console.log("Charts initialized."); } catch (error) { console.error("Error initializing charts:", error); downloadChart = null; uploadChart = null; } }
        function getBaseChartOptions(colors) { const currentTZ = selectedTimeZone || Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"; return { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false }, plugins: { legend: { position: 'top', labels:{ color: colors.textColor } }, tooltip: { mode: 'index', intersect: false, callbacks: { title: function(tooltipItems) { const date = tooltipItems[0]?.parsed?.x; if (date) { try { return new Intl.DateTimeFormat(undefined, { dateStyle: 'medium', timeStyle: 'medium', timeZone: currentTZ }).format(new Date(date)); } catch (e) { return new Date(date).toLocaleString(); } } return ''; } } } }, scales: { x: { type: 'time', time: { tooltipFormat: 'PPpp', unit: 'day', displayFormats: { millisecond: 'HH:mm:ss.SSS', second: 'HH:mm:ss', minute: 'HH:mm', hour: 'HH:mm', day: 'MMM d', week: 'MMM d', month: 'MMM yyyy', quarter: 'qqq yyyy', year: 'yyyy' } }, grid: { color: colors.gridColor }, ticks: { color: colors.textColor, maxRotation: 70, minRotation: 45, autoSkip: true, maxTicksLimit: 20, source: 'auto' } }, y: { beginAtZero: true, grid: { color: colors.gridColor }, ticks: { color: colors.textColor } } } }; }
        function processChartData() { let filtered = []; try { filtered = getFilteredHistory(); } catch (error) { console.error("Error getting filtered history for chart processing:", error); return { ostD: [], ssD: [], ostU: [], ssU: [] }; } const ostD = [], ssD = [], ostU = [], ssU = []; const sortedFiltered = filtered.slice().sort((a, b) => { if (!a.timestamp && !b.timestamp) return 0; if (!a.timestamp) return -1; if (!b.timestamp) return 1; try { const dateA = new Date(a.timestamp); const dateB = new Date(b.timestamp); const timeA = !isNaN(dateA.getTime()) ? dateA.getTime() : Infinity; const timeB = !isNaN(dateB.getTime()) ? dateB.getTime() : Infinity; return timeA - timeB; } catch(e) { return 0; } }); sortedFiltered.forEach(t => { if (!t.timestamp) return; let ts; try { ts = new Date(t.timestamp); if (isNaN(ts.getTime())) return; } catch (e) { return; } if (t.provider === 'openspeedtest') { ostD.push({ x: ts, y: t.download }); ostU.push({ x: ts, y: t.upload }); } else if (t.provider === 'speedsmart') { ssD.push({ x: ts, y: t.download }); ssU.push({ x: ts, y: t.upload }); } }); return { ostD, ssD, ostU, ssU }; }
        function updateCharts() { if (!(downloadChart instanceof Chart) || !(uploadChart instanceof Chart)) { initCharts(); if (!(downloadChart instanceof Chart) || !(uploadChart instanceof Chart)) { console.warn("Charts not initialized, cannot update."); return;} } console.log("Updating charts data..."); try{ const chartData = processChartData(); downloadChart.data.datasets[0].data = chartData.ostD; downloadChart.data.datasets[1].data = chartData.ssD; uploadChart.data.datasets[0].data = chartData.ostU; uploadChart.data.datasets[1].data = chartData.ssU; const colors = getChartColors(); downloadChart.options = getBaseChartOptions(colors); uploadChart.options = getBaseChartOptions(colors); downloadChart.update(); uploadChart.update(); console.log("Charts updated."); } catch(error){ console.error("Error updating charts:", error); }}
        function getChartColors() { const style = getComputedStyle(document.documentElement); const get = (v, f) => style.getPropertyValue(v).trim() || f; const isDarkMode = document.body.classList.contains('dark-mode'); const colors = { ostDownload: get('--primary-color', isDarkMode ? '#4d8edb' : '#0066cc'), ssDownload: get('--secondary-color', isDarkMode ? '#81c784' : '#4CAF50'), ostUpload: get('--tertiary-color', isDarkMode ? '#ffb74d' : '#ff9800'), ssUpload: get('--quaternary-color', isDarkMode ? '#ba68c8' : '#9c27b0'), textColor: get('--text-color', isDarkMode ? '#eee' : '#333'), gridColor: get('--chart-grid', isDarkMode ? '#333' : '#eee') }; colors.ostDownloadAlpha = colors.ostDownload + '33'; colors.ssDownloadAlpha = colors.ssDownload + '33'; colors.ostUploadAlpha = colors.ostUpload + '33'; colors.ssUploadAlpha = colors.ssUpload + '33'; return colors; }
        function updateChartsTheme() { if (!(downloadChart instanceof Chart) || !(uploadChart instanceof Chart)) { console.warn("Cannot update theme: Charts not initialized."); return; } console.log("Updating charts theme..."); try{ const colors = getChartColors(); const newOptions = getBaseChartOptions(colors); [downloadChart, uploadChart].forEach((chart) => { chart.options.plugins.legend.labels.color = colors.textColor; chart.options.scales.x.grid.color = colors.gridColor; chart.options.scales.x.ticks.color = colors.textColor; chart.options.scales.y.grid.color = colors.gridColor; chart.options.scales.y.ticks.color = colors.textColor; chart.options.plugins.tooltip = newOptions.plugins.tooltip; }); downloadChart.data.datasets[0].borderColor = colors.ostDownload; downloadChart.data.datasets[0].backgroundColor = colors.ostDownloadAlpha; downloadChart.data.datasets[1].borderColor = colors.ssDownload; downloadChart.data.datasets[1].backgroundColor = colors.ssDownloadAlpha; uploadChart.data.datasets[0].borderColor = colors.ostUpload; uploadChart.data.datasets[0].backgroundColor = colors.ostUploadAlpha; uploadChart.data.datasets[1].borderColor = colors.ssUpload; uploadChart.data.datasets[1].backgroundColor = colors.ssUploadAlpha; downloadChart.update(); uploadChart.update(); console.log("Charts theme updated."); } catch(error){ console.error("Error updating chart theme:", error);} }

        // --- Export Logic ---
        function exportHistory(type) { console.log(`Exporting history as ${type}...`); let dataToExport = []; try { dataToExport = getFilteredHistory(); } catch(error){ console.error("Error getting filtered data for export:", error); alert("Error preparing data for export."); return; } if (dataToExport.length === 0) { alert('No data matches filters to export.'); return; } try { const currentTZ = selectedTimeZone || Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"; let dateFormatter; try { dateFormatter = new Intl.DateTimeFormat(undefined, { year: 'numeric', month: 'short', day: '2-digit', hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: false, timeZone: currentTZ, timeZoneName: 'short' }); } catch(e) { console.error(`Invalid TZ "${currentTZ}" for export. Falling back to UTC.`, e); dateFormatter = new Intl.DateTimeFormat(undefined, { timeZone: "UTC", timeZoneName: 'short'}); } let content, filename, mimeType; const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0]; const filtersApplied = filterStartDateInput?.value || filterEndDateInput?.value || filterProviderSelect?.value !== 'all'; const filenameSuffix = filtersApplied ? `-filtered-${timestamp}` : `-${timestamp}`; const timezoneName = currentTZ.replace(/[/\s]/g, '_'); if (type === 'csv') { const headers = `"Date & Time (${dateFormatter.resolvedOptions().timeZone})","Provider","Download (Mbps)","Upload (Mbps)","Ping (ms)","Jitter (ms)","ISP"\n`; const rows = dataToExport.map(t => { let formattedDate = '-'; if (t.timestamp) { try { const d = new Date(t.timestamp); if(!isNaN(d.getTime())) formattedDate = dateFormatter.format(d); } catch(e){ formattedDate = 'Error'; } } const escapeCsvField = (field) => { const str = String(field ?? '-'); if (/[",\n]/.test(str)) { return `"${str.replace(/"/g, '""')}"`; } return str; }; return [ escapeCsvField(formattedDate), escapeCsvField(t.provider), (t.download || 0).toFixed(2), (t.upload || 0).toFixed(2), parseFloat(t.ping || 0).toFixed(1), (t.jitter || 0).toFixed(2), escapeCsvField(t.isp) ].join(','); }).join('\n'); content = headers + rows; filename = `speedtest-history-${timezoneName}${filenameSuffix}.csv`; mimeType = 'text/csv;charset=utf-8;'; } else { const jsonData = dataToExport.map(t => { let formatted_datetime_selected_tz = null; if (t.timestamp) { try { const d = new Date(t.timestamp); if(!isNaN(d.getTime())) formatted_datetime_selected_tz = dateFormatter.format(d); } catch(e){} } const { server, ...rest } = t; return { ...rest, timezone_used_for_format: currentTZ, formatted_datetime_selected_tz }; }); content = JSON.stringify(jsonData, null, 2); filename = `speedtest-history-${timezoneName}${filenameSuffix}.json`; mimeType = 'application/json;charset=utf-8;'; } const blob = new Blob([content], { type: mimeType }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = filename; document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a); console.log("Export successful."); } catch (error) { console.error("Error during export:", error); alert("An error occurred during export."); } }

    </script>

</body>
</html>
